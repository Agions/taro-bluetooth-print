{"file":"/Users/zfkc/Desktop/03-移动端项目/taro-bluetooth-print/tests/image.test.ts","mappings":";;AACA,8CAAqD;AAErD,QAAQ,CAAC,iBAAiB,EAAE,GAAG,EAAE;IAC/B,IAAI,CAAC,oCAAoC,EAAE,GAAG,EAAE;QAC9C,mCAAmC;QACnC,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;QAClD,MAAM,KAAK,GAAG,CAAC,CAAC;QAChB,MAAM,MAAM,GAAG,CAAC,CAAC;QACjB,MAAM,MAAM,GAAG,uBAAe,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7D,mBAAmB;QACnB,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,oCAAoC,EAAE,GAAG,EAAE;QAC9C,6BAA6B;QAC7B,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;QAC5C,MAAM,KAAK,GAAG,CAAC,CAAC;QAChB,MAAM,MAAM,GAAG,CAAC,CAAC;QACjB,MAAM,MAAM,GAAG,uBAAe,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7D,+CAA+C;QAC/C,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,yCAAyC,EAAE,GAAG,EAAE;QACnD,8CAA8C;QAC9C,qFAAqF;QACrF,8EAA8E;QAC9E,4BAA4B;QAC5B,0CAA0C;QAE1C,MAAM,IAAI,GAAG,IAAI,UAAU,CAAC;YAC1B,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,UAAU;YAC9B,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAE,UAAU;SAC/B,CAAC,CAAC;QACH,MAAM,KAAK,GAAG,CAAC,CAAC;QAChB,MAAM,MAAM,GAAG,CAAC,CAAC;QACjB,MAAM,MAAM,GAAG,uBAAe,CAAC,QAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;QAE7D,+BAA+B;QAC/B,uCAAuC;QACvC,+DAA+D;QAC/D,kFAAkF;QAClF,yCAAyC;QACzC,8BAA8B;QAE9B,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC7B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","names":[],"sources":["/Users/zfkc/Desktop/03-移动端项目/taro-bluetooth-print/tests/image.test.ts"],"sourcesContent":["\nimport { ImageProcessing } from '../src/utils/image';\n\ndescribe('ImageProcessing', () => {\n  test('toBitmap converts white pixel to 0', () => {\n    // RGBA: White (255, 255, 255, 255)\n    const data = new Uint8Array([255, 255, 255, 255]);\n    const width = 1;\n    const height = 1;\n    const bitmap = ImageProcessing.toBitmap(data, width, height);\n\n    // Expect 0 (white)\n    expect(bitmap[0]).toBe(0);\n  });\n\n  test('toBitmap converts black pixel to 1', () => {\n    // RGBA: Black (0, 0, 0, 255)\n    const data = new Uint8Array([0, 0, 0, 255]);\n    const width = 1;\n    const height = 1;\n    const bitmap = ImageProcessing.toBitmap(data, width, height);\n\n    // Expect 1 (black) - bit 7 set: 10000000 = 128\n    expect(bitmap[0]).toBe(128);\n  });\n\n  test('toBitmap handles dithering (gray pixel)', () => {\n    // RGBA: Gray (128, 128, 128, 255) - 2x1 image\n    // Pixel 1: Gray -> Threshold 128. 128 >= 128 -> White (0). Error = 128 - 255 = -127?\n    // Wait, logic: oldPixel = 128. newPixel = 128 < 128 ? 0 : 255 => 255 (White).\n    // Error = 128 - 255 = -127.\n    // Neighbor (Pixel 2) gets error * 7 / 16.\n\n    const data = new Uint8Array([\n      128, 128, 128, 255, // Pixel 1\n      128, 128, 128, 255  // Pixel 2\n    ]);\n    const width = 2;\n    const height = 1;\n    const bitmap = ImageProcessing.toBitmap(data, width, height);\n\n    // Byte 1 contains both pixels.\n    // Pixel 1 (x=0): White (0). Bit 7 = 0.\n    // Pixel 2 (x=1): Original 128 + (-127 * 7/16) = 128 - 55 = 73.\n    // 73 < 128 -> Black (0). Wait, logic: newPixel = 73 < 128 ? 0 : 255 => 0 (Black).\n    // So Pixel 2 should be Black. Bit 6 = 1.\n    // Result byte: 01000000 = 64.\n\n    expect(bitmap[0]).toBe(64);\n  });\n});\n"],"version":3}