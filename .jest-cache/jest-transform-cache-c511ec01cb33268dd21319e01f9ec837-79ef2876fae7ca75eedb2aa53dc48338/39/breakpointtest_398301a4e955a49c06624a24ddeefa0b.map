{"file":"/Users/zfkc/Desktop/03-移动端项目/taro-bluetooth-print/tests/breakpoint.test.ts","mappings":"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","names":[],"sources":["/Users/zfkc/Desktop/03-移动端项目/taro-bluetooth-print/tests/breakpoint.test.ts"],"sourcesContent":["\nimport { TextEncoder } from 'util';\nglobal.TextEncoder = TextEncoder as any;\n\nimport { BluetoothPrinter } from '../src/core/BluetoothPrinter';\nimport { TaroAdapter } from '../src/adapters/TaroAdapter';\nimport { PrinterState } from '../src/types';\n\n// Mock TaroAdapter\njest.mock('../src/adapters/TaroAdapter');\n\ndescribe('BluetoothPrinter Breakpoint', () => {\n  let printer: BluetoothPrinter;\n  let mockAdapter: jest.Mocked<TaroAdapter>;\n\n  beforeEach(() => {\n    mockAdapter = new TaroAdapter() as jest.Mocked<TaroAdapter>;\n    mockAdapter.write = jest.fn().mockResolvedValue(undefined);\n    mockAdapter.connect = jest.fn().mockResolvedValue(undefined);\n\n    printer = new BluetoothPrinter(mockAdapter);\n    printer.connect('test-device');\n  });\n\n  test('pause stops printing', async () => {\n    // Mock write to take some time so we can pause\n    mockAdapter.write.mockImplementation(async () => {\n      await new Promise(resolve => setTimeout(resolve, 10));\n    });\n\n    // Add a lot of data (more than 512 bytes chunk size)\n    const data = new Uint8Array(1024);\n    printer.text('test'); // Just adds to buffer, but let's manually fill buffer for control\n    // Access private buffer via any cast or just use public methods\n    // printer.text adds to buffer.\n    // Let's add enough text.\n    for (let i = 0; i < 100; i++) {\n      printer.text('1234567890'); // 10 bytes * 100 = 1000 bytes\n    }\n\n    const printPromise = printer.print();\n\n    // Pause immediately\n    printer.pause();\n\n    await printPromise;\n\n    // Should have stopped early.\n    // Check remaining bytes.\n    expect(printer.remaining()).toBeGreaterThan(0);\n    expect(printer.state).toBe(PrinterState.PAUSED);\n  });\n\n  test('resume continues printing', async () => {\n    // Mock write\n    mockAdapter.write.mockResolvedValue(undefined);\n\n    // Add data\n    for (let i = 0; i < 100; i++) {\n      printer.text('1234567890');\n    }\n\n    // Start print\n    const printPromise = printer.print();\n\n    // Pause\n    printer.pause();\n    await printPromise;\n\n    const remainingBefore = printer.remaining();\n    expect(remainingBefore).toBeGreaterThan(0);\n\n    // Resume\n    await printer.resume();\n\n    expect(printer.remaining()).toBe(0);\n    // State should be PRINTING then done (which resets to null jobBuffer, but state might remain PRINTING or we didn't reset it to CONNECTED in processJob?\n    // Let's check processJob implementation.\n    // It doesn't reset state to CONNECTED at the end.\n    // I should probably fix that.\n  });\n\n  test('cancel clears job', async () => {\n    // Add data\n    printer.text('test');\n\n    const printPromise = printer.print();\n    printer.pause();\n    await printPromise;\n\n    expect(printer.remaining()).toBeGreaterThan(0);\n\n    printer.cancel();\n\n    expect(printer.remaining()).toBe(0);\n    expect(printer.state).toBe(PrinterState.CONNECTED);\n  });\n});\n"],"version":3}