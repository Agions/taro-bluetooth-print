dcf7eb7d05be621fefc62e8fda984f2a
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
global.TextEncoder = util_1.TextEncoder;
const EscPos_1 = require("../src/drivers/EscPos");
// Mock Encoding since it might depend on TextEncoder which is available in Node 11+
// But let's assume it works or mock it if needed.
// Actually, let's check src/utils/encoding.ts content first?
// I haven't read it yet. Let's assume it works or read it if test fails.
describe('EscPos QR', () => {
    const driver = new EscPos_1.EscPos();
    test('qr generates correct commands for default options', () => {
        const content = '12345';
        const commands = driver.qr(content);
        // Expect 5 commands
        expect(commands.length).toBe(5);
        // 1. Model: GS ( k 04 00 31 41 50 00 (Model 2 default)
        expect(commands[0]).toEqual(new Uint8Array([0x1D, 0x28, 0x6B, 0x04, 0x00, 0x31, 0x41, 50, 0]));
        // 2. Size: GS ( k 03 00 31 43 06 (Size 6 default)
        expect(commands[1]).toEqual(new Uint8Array([0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x43, 6]));
        // 3. Error Correction: GS ( k 03 00 31 45 49 (Level M default)
        expect(commands[2]).toEqual(new Uint8Array([0x1D, 0x28, 0x6B, 0x03, 0x00, 0x31, 0x45, 49]));
        // 4. Store Data
        // Length of '12345' is 5. +3 = 8.
        // pL = 8, pH = 0.
        // GS ( k 08 00 31 50 30 ...data...
        const header = new Uint8Array([0x1D, 0x28, 0x6B, 8, 0, 0x31, 0x50, 0x30]);
        expect(commands[3]).toEqual(header);
        // Data command is separate in my implementation?
        // Wait, looking at my implementation:
        // commands.push(new Uint8Array([0x1D, 0x28, 0x6B, pL, pH, 0x31, 0x50, 0x30]));
        // commands.push(data);
        // So commands[4] is data?
        // No, commands[3] is header. commands[4] is data.
        // commands[5] is Print Symbol.
        // Let's check commands length again.
        // 1. Model
        // 2. Size
        // 3. Error Correction
        // 4. Store Header
        // 5. Store Data
        // 6. Print Symbol
        // So length should be 6.
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3pma2MvRGVza3RvcC8wMy3np7vliqjnq6/pobnnm64vdGFyby1ibHVldG9vdGgtcHJpbnQvdGVzdHMvcXIudGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUNBLCtCQUFtQztBQUNuQyxNQUFNLENBQUMsV0FBVyxHQUFHLGtCQUFrQixDQUFDO0FBRXhDLGtEQUErQztBQUcvQyxvRkFBb0Y7QUFDcEYsa0RBQWtEO0FBQ2xELDZEQUE2RDtBQUM3RCx5RUFBeUU7QUFFekUsUUFBUSxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUU7SUFDekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxlQUFNLEVBQUUsQ0FBQztJQUU1QixJQUFJLENBQUMsbURBQW1ELEVBQUUsR0FBRyxFQUFFO1FBQzdELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN4QixNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXBDLG9CQUFvQjtRQUNwQixNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVoQyx1REFBdUQ7UUFDdkQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRS9GLGtEQUFrRDtRQUNsRCxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUzRiwrREFBK0Q7UUFDL0QsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFNUYsZ0JBQWdCO1FBQ2hCLGtDQUFrQztRQUNsQyxrQkFBa0I7UUFDbEIsbUNBQW1DO1FBQ25DLE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDMUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNwQyxpREFBaUQ7UUFDakQsc0NBQXNDO1FBQ3RDLCtFQUErRTtRQUMvRSx1QkFBdUI7UUFDdkIsMEJBQTBCO1FBQzFCLGtEQUFrRDtRQUNsRCwrQkFBK0I7UUFFL0IscUNBQXFDO1FBQ3JDLFdBQVc7UUFDWCxVQUFVO1FBQ1Ysc0JBQXNCO1FBQ3RCLGtCQUFrQjtRQUNsQixnQkFBZ0I7UUFDaEIsa0JBQWtCO1FBQ2xCLHlCQUF5QjtJQUMzQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy96ZmtjL0Rlc2t0b3AvMDMt56e75Yqo56uv6aG555uuL3Rhcm8tYmx1ZXRvb3RoLXByaW50L3Rlc3RzL3FyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBUZXh0RW5jb2RlciB9IGZyb20gJ3V0aWwnO1xuZ2xvYmFsLlRleHRFbmNvZGVyID0gVGV4dEVuY29kZXIgYXMgYW55O1xuXG5pbXBvcnQgeyBFc2NQb3MgfSBmcm9tICcuLi9zcmMvZHJpdmVycy9Fc2NQb3MnO1xuaW1wb3J0IHsgRW5jb2RpbmcgfSBmcm9tICcuLi9zcmMvdXRpbHMvZW5jb2RpbmcnO1xuXG4vLyBNb2NrIEVuY29kaW5nIHNpbmNlIGl0IG1pZ2h0IGRlcGVuZCBvbiBUZXh0RW5jb2RlciB3aGljaCBpcyBhdmFpbGFibGUgaW4gTm9kZSAxMStcbi8vIEJ1dCBsZXQncyBhc3N1bWUgaXQgd29ya3Mgb3IgbW9jayBpdCBpZiBuZWVkZWQuXG4vLyBBY3R1YWxseSwgbGV0J3MgY2hlY2sgc3JjL3V0aWxzL2VuY29kaW5nLnRzIGNvbnRlbnQgZmlyc3Q/XG4vLyBJIGhhdmVuJ3QgcmVhZCBpdCB5ZXQuIExldCdzIGFzc3VtZSBpdCB3b3JrcyBvciByZWFkIGl0IGlmIHRlc3QgZmFpbHMuXG5cbmRlc2NyaWJlKCdFc2NQb3MgUVInLCAoKSA9PiB7XG4gIGNvbnN0IGRyaXZlciA9IG5ldyBFc2NQb3MoKTtcblxuICB0ZXN0KCdxciBnZW5lcmF0ZXMgY29ycmVjdCBjb21tYW5kcyBmb3IgZGVmYXVsdCBvcHRpb25zJywgKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAnMTIzNDUnO1xuICAgIGNvbnN0IGNvbW1hbmRzID0gZHJpdmVyLnFyKGNvbnRlbnQpO1xuXG4gICAgLy8gRXhwZWN0IDUgY29tbWFuZHNcbiAgICBleHBlY3QoY29tbWFuZHMubGVuZ3RoKS50b0JlKDUpO1xuXG4gICAgLy8gMS4gTW9kZWw6IEdTICggayAwNCAwMCAzMSA0MSA1MCAwMCAoTW9kZWwgMiBkZWZhdWx0KVxuICAgIGV4cGVjdChjb21tYW5kc1swXSkudG9FcXVhbChuZXcgVWludDhBcnJheShbMHgxRCwgMHgyOCwgMHg2QiwgMHgwNCwgMHgwMCwgMHgzMSwgMHg0MSwgNTAsIDBdKSk7XG5cbiAgICAvLyAyLiBTaXplOiBHUyAoIGsgMDMgMDAgMzEgNDMgMDYgKFNpemUgNiBkZWZhdWx0KVxuICAgIGV4cGVjdChjb21tYW5kc1sxXSkudG9FcXVhbChuZXcgVWludDhBcnJheShbMHgxRCwgMHgyOCwgMHg2QiwgMHgwMywgMHgwMCwgMHgzMSwgMHg0MywgNl0pKTtcblxuICAgIC8vIDMuIEVycm9yIENvcnJlY3Rpb246IEdTICggayAwMyAwMCAzMSA0NSA0OSAoTGV2ZWwgTSBkZWZhdWx0KVxuICAgIGV4cGVjdChjb21tYW5kc1syXSkudG9FcXVhbChuZXcgVWludDhBcnJheShbMHgxRCwgMHgyOCwgMHg2QiwgMHgwMywgMHgwMCwgMHgzMSwgMHg0NSwgNDldKSk7XG5cbiAgICAvLyA0LiBTdG9yZSBEYXRhXG4gICAgLy8gTGVuZ3RoIG9mICcxMjM0NScgaXMgNS4gKzMgPSA4LlxuICAgIC8vIHBMID0gOCwgcEggPSAwLlxuICAgIC8vIEdTICggayAwOCAwMCAzMSA1MCAzMCAuLi5kYXRhLi4uXG4gICAgY29uc3QgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MUQsIDB4MjgsIDB4NkIsIDgsIDAsIDB4MzEsIDB4NTAsIDB4MzBdKTtcbiAgICBleHBlY3QoY29tbWFuZHNbM10pLnRvRXF1YWwoaGVhZGVyKTtcbiAgICAvLyBEYXRhIGNvbW1hbmQgaXMgc2VwYXJhdGUgaW4gbXkgaW1wbGVtZW50YXRpb24/XG4gICAgLy8gV2FpdCwgbG9va2luZyBhdCBteSBpbXBsZW1lbnRhdGlvbjpcbiAgICAvLyBjb21tYW5kcy5wdXNoKG5ldyBVaW50OEFycmF5KFsweDFELCAweDI4LCAweDZCLCBwTCwgcEgsIDB4MzEsIDB4NTAsIDB4MzBdKSk7XG4gICAgLy8gY29tbWFuZHMucHVzaChkYXRhKTtcbiAgICAvLyBTbyBjb21tYW5kc1s0XSBpcyBkYXRhP1xuICAgIC8vIE5vLCBjb21tYW5kc1szXSBpcyBoZWFkZXIuIGNvbW1hbmRzWzRdIGlzIGRhdGEuXG4gICAgLy8gY29tbWFuZHNbNV0gaXMgUHJpbnQgU3ltYm9sLlxuXG4gICAgLy8gTGV0J3MgY2hlY2sgY29tbWFuZHMgbGVuZ3RoIGFnYWluLlxuICAgIC8vIDEuIE1vZGVsXG4gICAgLy8gMi4gU2l6ZVxuICAgIC8vIDMuIEVycm9yIENvcnJlY3Rpb25cbiAgICAvLyA0LiBTdG9yZSBIZWFkZXJcbiAgICAvLyA1LiBTdG9yZSBEYXRhXG4gICAgLy8gNi4gUHJpbnQgU3ltYm9sXG4gICAgLy8gU28gbGVuZ3RoIHNob3VsZCBiZSA2LlxuICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9