88d9c53430168daebb47caa3951d6cd5
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Mock TaroAdapter
jest.mock('../src/adapters/TaroAdapter');
const util_1 = require("util");
global.TextEncoder = util_1.TextEncoder;
const BluetoothPrinter_1 = require("../src/core/BluetoothPrinter");
const TaroAdapter_1 = require("../src/adapters/TaroAdapter");
const types_1 = require("../src/types");
describe('BluetoothPrinter Breakpoint', () => {
    let printer;
    let mockAdapter;
    beforeEach(() => {
        mockAdapter = new TaroAdapter_1.TaroAdapter();
        mockAdapter.write = jest.fn().mockResolvedValue(undefined);
        mockAdapter.connect = jest.fn().mockResolvedValue(undefined);
        printer = new BluetoothPrinter_1.BluetoothPrinter(mockAdapter);
        printer.connect('test-device');
    });
    test('pause stops printing', async () => {
        // Mock write to take some time so we can pause
        mockAdapter.write.mockImplementation(async () => {
            await new Promise(resolve => setTimeout(resolve, 10));
        });
        // Add a lot of data (more than 512 bytes chunk size)
        const data = new Uint8Array(1024);
        printer.text('test'); // Just adds to buffer, but let's manually fill buffer for control
        // Access private buffer via any cast or just use public methods
        // printer.text adds to buffer.
        // Let's add enough text.
        for (let i = 0; i < 100; i++) {
            printer.text('1234567890'); // 10 bytes * 100 = 1000 bytes
        }
        const printPromise = printer.print();
        // Pause immediately
        printer.pause();
        await printPromise;
        // Should have stopped early.
        // Check remaining bytes.
        expect(printer.remaining()).toBeGreaterThan(0);
        expect(printer.state).toBe(types_1.PrinterState.PAUSED);
    });
    test('resume continues printing', async () => {
        // Mock write
        mockAdapter.write.mockResolvedValue(undefined);
        // Add data
        for (let i = 0; i < 100; i++) {
            printer.text('1234567890');
        }
        // Start print
        const printPromise = printer.print();
        // Pause
        printer.pause();
        await printPromise;
        const remainingBefore = printer.remaining();
        expect(remainingBefore).toBeGreaterThan(0);
        // Resume
        await printer.resume();
        expect(printer.remaining()).toBe(0);
        // State should be PRINTING then done (which resets to null jobBuffer, but state might remain PRINTING or we didn't reset it to CONNECTED in processJob?
        // Let's check processJob implementation.
        // It doesn't reset state to CONNECTED at the end.
        // I should probably fix that.
    });
    test('cancel clears job', async () => {
        // Mock write with delay
        mockAdapter.write.mockImplementation(async () => {
            await new Promise(resolve => setTimeout(resolve, 10));
        });
        // Add data
        printer.text('test');
        const printPromise = printer.print();
        printer.pause();
        await printPromise;
        expect(printer.remaining()).toBeGreaterThan(0);
        printer.cancel();
        expect(printer.remaining()).toBe(0);
        expect(printer.state).toBe(types_1.PrinterState.CONNECTED);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL3pma2MvRGVza3RvcC8wMy3np7vliqjnq6/pobnnm64vdGFyby1ibHVldG9vdGgtcHJpbnQvdGVzdHMvYnJlYWtwb2ludC50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBUUEsbUJBQW1CO0FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztBQVJ6QywrQkFBbUM7QUFDbkMsTUFBTSxDQUFDLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQztBQUV4QyxtRUFBZ0U7QUFDaEUsNkRBQTBEO0FBQzFELHdDQUE0QztBQUs1QyxRQUFRLENBQUMsNkJBQTZCLEVBQUUsR0FBRyxFQUFFO0lBQzNDLElBQUksT0FBeUIsQ0FBQztJQUM5QixJQUFJLFdBQXFDLENBQUM7SUFFMUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLFdBQVcsR0FBRyxJQUFJLHlCQUFXLEVBQThCLENBQUM7UUFDNUQsV0FBVyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0QsV0FBVyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFN0QsT0FBTyxHQUFHLElBQUksbUNBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDNUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNqQyxDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxzQkFBc0IsRUFBRSxLQUFLLElBQUksRUFBRTtRQUN0QywrQ0FBK0M7UUFDL0MsV0FBVyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUM5QyxNQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hELENBQUMsQ0FBQyxDQUFDO1FBRUgscURBQXFEO1FBQ3JELE1BQU0sSUFBSSxHQUFHLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxrRUFBa0U7UUFDeEYsZ0VBQWdFO1FBQ2hFLCtCQUErQjtRQUMvQix5QkFBeUI7UUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzdCLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyw4QkFBOEI7UUFDNUQsQ0FBQztRQUVELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUVyQyxvQkFBb0I7UUFDcEIsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBRWhCLE1BQU0sWUFBWSxDQUFDO1FBRW5CLDZCQUE2QjtRQUM3Qix5QkFBeUI7UUFDekIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxvQkFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xELENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLDJCQUEyQixFQUFFLEtBQUssSUFBSSxFQUFFO1FBQzNDLGFBQWE7UUFDYixXQUFXLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRS9DLFdBQVc7UUFDWCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0IsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM3QixDQUFDO1FBRUQsY0FBYztRQUNkLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUVyQyxRQUFRO1FBQ1IsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2hCLE1BQU0sWUFBWSxDQUFDO1FBRW5CLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUM1QyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTNDLFNBQVM7UUFDVCxNQUFNLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUV2QixNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLHdKQUF3SjtRQUN4Six5Q0FBeUM7UUFDekMsa0RBQWtEO1FBQ2xELDhCQUE4QjtJQUNoQyxDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLElBQUksRUFBRTtRQUNuQyx3QkFBd0I7UUFDeEIsV0FBVyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUM5QyxNQUFNLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hELENBQUMsQ0FBQyxDQUFDO1FBRUgsV0FBVztRQUNYLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckIsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3JDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNoQixNQUFNLFlBQVksQ0FBQztRQUVuQixNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRS9DLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUVqQixNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLG9CQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDckQsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvemZrYy9EZXNrdG9wLzAzLeenu+WKqOerr+mhueebri90YXJvLWJsdWV0b290aC1wcmludC90ZXN0cy9icmVha3BvaW50LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBUZXh0RW5jb2RlciB9IGZyb20gJ3V0aWwnO1xuZ2xvYmFsLlRleHRFbmNvZGVyID0gVGV4dEVuY29kZXIgYXMgYW55O1xuXG5pbXBvcnQgeyBCbHVldG9vdGhQcmludGVyIH0gZnJvbSAnLi4vc3JjL2NvcmUvQmx1ZXRvb3RoUHJpbnRlcic7XG5pbXBvcnQgeyBUYXJvQWRhcHRlciB9IGZyb20gJy4uL3NyYy9hZGFwdGVycy9UYXJvQWRhcHRlcic7XG5pbXBvcnQgeyBQcmludGVyU3RhdGUgfSBmcm9tICcuLi9zcmMvdHlwZXMnO1xuXG4vLyBNb2NrIFRhcm9BZGFwdGVyXG5qZXN0Lm1vY2soJy4uL3NyYy9hZGFwdGVycy9UYXJvQWRhcHRlcicpO1xuXG5kZXNjcmliZSgnQmx1ZXRvb3RoUHJpbnRlciBCcmVha3BvaW50JywgKCkgPT4ge1xuICBsZXQgcHJpbnRlcjogQmx1ZXRvb3RoUHJpbnRlcjtcbiAgbGV0IG1vY2tBZGFwdGVyOiBqZXN0Lk1vY2tlZDxUYXJvQWRhcHRlcj47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja0FkYXB0ZXIgPSBuZXcgVGFyb0FkYXB0ZXIoKSBhcyBqZXN0Lk1vY2tlZDxUYXJvQWRhcHRlcj47XG4gICAgbW9ja0FkYXB0ZXIud3JpdGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICBtb2NrQWRhcHRlci5jb25uZWN0ID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICBwcmludGVyID0gbmV3IEJsdWV0b290aFByaW50ZXIobW9ja0FkYXB0ZXIpO1xuICAgIHByaW50ZXIuY29ubmVjdCgndGVzdC1kZXZpY2UnKTtcbiAgfSk7XG5cbiAgdGVzdCgncGF1c2Ugc3RvcHMgcHJpbnRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gTW9jayB3cml0ZSB0byB0YWtlIHNvbWUgdGltZSBzbyB3ZSBjYW4gcGF1c2VcbiAgICBtb2NrQWRhcHRlci53cml0ZS5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYSBsb3Qgb2YgZGF0YSAobW9yZSB0aGFuIDUxMiBieXRlcyBjaHVuayBzaXplKVxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSgxMDI0KTtcbiAgICBwcmludGVyLnRleHQoJ3Rlc3QnKTsgLy8gSnVzdCBhZGRzIHRvIGJ1ZmZlciwgYnV0IGxldCdzIG1hbnVhbGx5IGZpbGwgYnVmZmVyIGZvciBjb250cm9sXG4gICAgLy8gQWNjZXNzIHByaXZhdGUgYnVmZmVyIHZpYSBhbnkgY2FzdCBvciBqdXN0IHVzZSBwdWJsaWMgbWV0aG9kc1xuICAgIC8vIHByaW50ZXIudGV4dCBhZGRzIHRvIGJ1ZmZlci5cbiAgICAvLyBMZXQncyBhZGQgZW5vdWdoIHRleHQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgcHJpbnRlci50ZXh0KCcxMjM0NTY3ODkwJyk7IC8vIDEwIGJ5dGVzICogMTAwID0gMTAwMCBieXRlc1xuICAgIH1cblxuICAgIGNvbnN0IHByaW50UHJvbWlzZSA9IHByaW50ZXIucHJpbnQoKTtcblxuICAgIC8vIFBhdXNlIGltbWVkaWF0ZWx5XG4gICAgcHJpbnRlci5wYXVzZSgpO1xuXG4gICAgYXdhaXQgcHJpbnRQcm9taXNlO1xuXG4gICAgLy8gU2hvdWxkIGhhdmUgc3RvcHBlZCBlYXJseS5cbiAgICAvLyBDaGVjayByZW1haW5pbmcgYnl0ZXMuXG4gICAgZXhwZWN0KHByaW50ZXIucmVtYWluaW5nKCkpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICBleHBlY3QocHJpbnRlci5zdGF0ZSkudG9CZShQcmludGVyU3RhdGUuUEFVU0VEKTtcbiAgfSk7XG5cbiAgdGVzdCgncmVzdW1lIGNvbnRpbnVlcyBwcmludGluZycsIGFzeW5jICgpID0+IHtcbiAgICAvLyBNb2NrIHdyaXRlXG4gICAgbW9ja0FkYXB0ZXIud3JpdGUubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgIC8vIEFkZCBkYXRhXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgcHJpbnRlci50ZXh0KCcxMjM0NTY3ODkwJyk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgcHJpbnRcbiAgICBjb25zdCBwcmludFByb21pc2UgPSBwcmludGVyLnByaW50KCk7XG5cbiAgICAvLyBQYXVzZVxuICAgIHByaW50ZXIucGF1c2UoKTtcbiAgICBhd2FpdCBwcmludFByb21pc2U7XG5cbiAgICBjb25zdCByZW1haW5pbmdCZWZvcmUgPSBwcmludGVyLnJlbWFpbmluZygpO1xuICAgIGV4cGVjdChyZW1haW5pbmdCZWZvcmUpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgIC8vIFJlc3VtZVxuICAgIGF3YWl0IHByaW50ZXIucmVzdW1lKCk7XG5cbiAgICBleHBlY3QocHJpbnRlci5yZW1haW5pbmcoKSkudG9CZSgwKTtcbiAgICAvLyBTdGF0ZSBzaG91bGQgYmUgUFJJTlRJTkcgdGhlbiBkb25lICh3aGljaCByZXNldHMgdG8gbnVsbCBqb2JCdWZmZXIsIGJ1dCBzdGF0ZSBtaWdodCByZW1haW4gUFJJTlRJTkcgb3Igd2UgZGlkbid0IHJlc2V0IGl0IHRvIENPTk5FQ1RFRCBpbiBwcm9jZXNzSm9iP1xuICAgIC8vIExldCdzIGNoZWNrIHByb2Nlc3NKb2IgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gSXQgZG9lc24ndCByZXNldCBzdGF0ZSB0byBDT05ORUNURUQgYXQgdGhlIGVuZC5cbiAgICAvLyBJIHNob3VsZCBwcm9iYWJseSBmaXggdGhhdC5cbiAgfSk7XG5cbiAgdGVzdCgnY2FuY2VsIGNsZWFycyBqb2InLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gTW9jayB3cml0ZSB3aXRoIGRlbGF5XG4gICAgbW9ja0FkYXB0ZXIud3JpdGUubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGRhdGFcbiAgICBwcmludGVyLnRleHQoJ3Rlc3QnKTtcblxuICAgIGNvbnN0IHByaW50UHJvbWlzZSA9IHByaW50ZXIucHJpbnQoKTtcbiAgICBwcmludGVyLnBhdXNlKCk7XG4gICAgYXdhaXQgcHJpbnRQcm9taXNlO1xuXG4gICAgZXhwZWN0KHByaW50ZXIucmVtYWluaW5nKCkpLnRvQmVHcmVhdGVyVGhhbigwKTtcblxuICAgIHByaW50ZXIuY2FuY2VsKCk7XG5cbiAgICBleHBlY3QocHJpbnRlci5yZW1haW5pbmcoKSkudG9CZSgwKTtcbiAgICBleHBlY3QocHJpbnRlci5zdGF0ZSkudG9CZShQcmludGVyU3RhdGUuQ09OTkVDVEVEKTtcbiAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==