name: Enhanced Test Reporting

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_run:
    workflows: ["CI/CD Pipeline (Optimized)"]
    types: [completed]

env:
  NODE_VERSION: '18'

jobs:
  # 生成增强测试报告
  generate-enhanced-reports:
    name: Generate Enhanced Test Reports
    runs-on: ubuntu-latest
    if: github.event.workflow_run?.conclusion == 'success' || github.event_name != 'workflow_run'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm ci

      - name: Download test artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
        continue-on-error: true

      - name: Generate unified test report
        run: |
          # 创建增强的测试报告生成脚本
          cat > scripts/generate-enhanced-test-report.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          class EnhancedTestReportGenerator {
            constructor(options = {}) {
              this.projectName = options.projectName || 'Taro Bluetooth Print';
              this.outputDir = options.outputDir || 'test-reports';
              this.artifactsDir = options.artifactsDir || 'artifacts';
              this.reportData = {
                summary: {},
                details: {},
                metrics: {},
                trends: {}
              };
            }

            async generate() {
              console.log('🚀 开始生成增强测试报告...');

              await this.collectArtifacts();
              await this.analyzeTestResults();
              await this.generateHTMLReport();
              await this.generateJSONReport();
              await this.generateMarkdownReport();

              console.log('✅ 测试报告生成完成!');
            }

            async collectArtifacts() {
              const artifactsDir = path.join(process.cwd(), this.artifactsDir);

              if (!fs.existsSync(artifactsDir)) {
                console.log('⚠️ 未找到artifacts目录');
                return;
              }

              const artifactTypes = ['unit', 'integration', 'e2e', 'performance', 'coverage'];

              for (const type of artifactTypes) {
                const typeDir = path.join(artifactsDir, `${type}-test-results-node18`);
                if (fs.existsSync(typeDir)) {
                  this.reportData.details[type] = this.readTestResults(typeDir);
                }
              }
            }

            readTestResults(dir) {
              const results = {
                passed: 0,
                failed: 0,
                skipped: 0,
                total: 0,
                duration: 0,
                tests: []
              };

              try {
                // 读取Junit XML报告
                const junitFiles = this.findFiles(dir, '.xml');
                for (const file of junitFiles) {
                  const content = fs.readFileSync(file, 'utf8');
                  // 简单的XML解析
                  const testMatches = content.match(/tests="(\d+)" failures="(\d+)" errors="(\d+)" skipped="(\d+)" time="([\d.]+)"/g);

                  if (testMatches) {
                    for (const match of testMatches) {
                      const [, total, failures, errors, skipped, time] = match.match(/tests="(\d+)" failures="(\d+)" errors="(\d+)" skipped="(\d+)" time="([\d.]+)"/);
                      results.total += parseInt(total);
                      results.failed += parseInt(failures) + parseInt(errors);
                      results.skipped += parseInt(skipped);
                      results.passed += parseInt(total) - parseInt(failures) - parseInt(errors) - parseInt(skipped);
                      results.duration += parseFloat(time);
                    }
                  }
                }

                // 读取JSON报告
                const jsonFiles = this.findFiles(dir, '.json');
                for (const file of jsonFiles) {
                  try {
                    const data = JSON.parse(fs.readFileSync(file, 'utf8'));
                    if (data.testResults) {
                      results.tests.push(...data.testResults);
                    }
                  } catch (e) {
                    console.log(`无法解析JSON文件: ${file}`);
                  }
                }
              } catch (error) {
                console.error(`读取测试结果失败: ${error.message}`);
              }

              return results;
            }

            findFiles(dir, extension) {
              const files = [];
              const search = (currentDir) => {
                const items = fs.readdirSync(currentDir);
                for (const item of items) {
                  const fullPath = path.join(currentDir, item);
                  const stat = fs.statSync(fullPath);

                  if (stat.isDirectory()) {
                    search(fullPath);
                  } else if (item.endsWith(extension)) {
                    files.push(fullPath);
                  }
                }
              };
              search(dir);
              return files;
            }

            async analyzeTestResults() {
              const summary = {
                totalTests: 0,
                totalPassed: 0,
                totalFailed: 0,
                totalSkipped: 0,
                totalDuration: 0,
                successRate: 0,
                testTypes: Object.keys(this.reportData.details)
              };

              for (const [type, results] of Object.entries(this.reportData.details)) {
                summary.totalTests += results.total;
                summary.totalPassed += results.passed;
                summary.totalFailed += results.failed;
                summary.totalSkipped += results.skipped;
                summary.totalDuration += results.duration;
              }

              summary.successRate = summary.totalTests > 0
                ? ((summary.totalPassed / summary.totalTests) * 100).toFixed(2)
                : 0;

              this.reportData.summary = summary;
              this.reportData.metrics = this.calculateMetrics(summary);
            }

            calculateMetrics(summary) {
              return {
                testPerformance: {
                  avgTestTime: summary.totalTests > 0 ? (summary.totalDuration / summary.totalTests).toFixed(2) : 0,
                  testsPerMinute: summary.totalDuration > 0 ? Math.round((summary.totalTests / summary.totalDuration) * 60) : 0
                },
                qualityMetrics: {
                  successRate: parseFloat(summary.successRate),
                  failureRate: summary.totalTests > 0 ? ((summary.totalFailed / summary.totalTests) * 100).toFixed(2) : 0,
                  skipRate: summary.totalTests > 0 ? ((summary.totalSkipped / summary.totalTests) * 100).toFixed(2) : 0
                },
                coverageMetrics: this.extractCoverageMetrics()
              };
            }

            extractCoverageMetrics() {
              const coverageDir = path.join(process.cwd(), this.artifactsDir, 'coverage-reports');
              if (!fs.existsSync(coverageDir)) {
                return { lines: 0, functions: 0, branches: 0, statements: 0 };
              }

              try {
                const coverageFile = path.join(coverageDir, 'coverage', 'coverage-summary.json');
                if (fs.existsSync(coverageFile)) {
                  const data = JSON.parse(fs.readFileSync(coverageFile, 'utf8'));
                  return {
                    lines: data.total?.lines?.pct || 0,
                    functions: data.total?.functions?.pct || 0,
                    branches: data.total?.branches?.pct || 0,
                    statements: data.total?.statements?.pct || 0
                  };
                }
              } catch (error) {
                console.log(`无法读取覆盖率数据: ${error.message}`);
              }

              return { lines: 0, functions: 0, branches: 0, statements: 0 };
            }

            async generateHTMLReport() {
              const html = this.generateHTMLContent();
              const outputPath = path.join(this.outputDir, 'enhanced-test-report.html');

              if (!fs.existsSync(this.outputDir)) {
                fs.mkdirSync(this.outputDir, { recursive: true });
              }

              fs.writeFileSync(outputPath, html);
              console.log(`📄 HTML报告已生成: ${outputPath}`);
            }

            generateHTMLContent() {
              const { summary, metrics } = this.reportData;
              const coverage = metrics.coverageMetrics;

              return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.projectName} - 增强测试报告</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 8px 8px 0 0; }
        .content { padding: 30px; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .metric-card { background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid #007bff; }
        .metric-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .metric-label { color: #6c757d; margin-top: 5px; }
        .progress-bar { background: #e9ecef; border-radius: 4px; overflow: hidden; height: 8px; margin-top: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #28a745, #20c997); transition: width 0.3s ease; }
        .test-types { margin-top: 30px; }
        .test-type { background: #fff; border: 1px solid #dee2e6; border-radius: 8px; margin-bottom: 15px; overflow: hidden; }
        .test-type-header { background: #f8f9fa; padding: 15px; font-weight: bold; display: flex; justify-content: space-between; }
        .test-type-details { padding: 15px; display: none; }
        .test-type.active .test-type-details { display: block; }
        .coverage-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px; }
        .coverage-item { text-align: center; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .coverage-value { font-size: 1.5em; font-weight: bold; }
        .high-coverage { color: #28a745; }
        .medium-coverage { color: #ffc107; }
        .low-coverage { color: #dc3545; }
        .timestamp { color: #6c757d; text-align: center; margin-top: 30px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>${this.projectName} 测试报告</h1>
            <p>生成时间: ${new Date().toLocaleString('zh-CN')}</p>
        </div>

        <div class="content">
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value">${summary.totalTests}</div>
                    <div class="metric-label">总测试数</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${summary.successRate}%</div>
                    <div class="metric-label">成功率</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${summary.successRate}%"></div>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${summary.totalDuration.toFixed(2)}s</div>
                    <div class="metric-label">总执行时间</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${metrics.testPerformance.testsPerMinute}</div>
                    <div class="metric-label">测试/分钟</div>
                </div>
            </div>

            <div class="coverage-grid">
                <div class="coverage-item">
                    <div class="coverage-value ${coverage.lines >= 80 ? 'high-coverage' : coverage.lines >= 60 ? 'medium-coverage' : 'low-coverage'}">${coverage.lines}%</div>
                    <div>行覆盖率</div>
                </div>
                <div class="coverage-item">
                    <div class="coverage-value ${coverage.functions >= 80 ? 'high-coverage' : coverage.functions >= 60 ? 'medium-coverage' : 'low-coverage'}">${coverage.functions}%</div>
                    <div>函数覆盖率</div>
                </div>
                <div class="coverage-item">
                    <div class="coverage-value ${coverage.branches >= 80 ? 'high-coverage' : coverage.branches >= 60 ? 'medium-coverage' : 'low-coverage'}">${coverage.branches}%</div>
                    <div>分支覆盖率</div>
                </div>
                <div class="coverage-item">
                    <div class="coverage-value ${coverage.statements >= 80 ? 'high-coverage' : coverage.statements >= 60 ? 'medium-coverage' : 'low-coverage'}">${coverage.statements}%</div>
                    <div>语句覆盖率</div>
                </div>
            </div>

            <div class="test-types">
                <h3>测试类型详情</h3>
                ${summary.testTypes.map(type => {
                  const results = this.reportData.details[type];
                  const successRate = results.total > 0 ? ((results.passed / results.total) * 100).toFixed(2) : 0;
                  return `
                    <div class="test-type" onclick="this.classList.toggle('active')">
                        <div class="test-type-header">
                            <span>${type.toUpperCase()}</span>
                            <span style="color: ${successRate >= 95 ? '#28a745' : successRate >= 80 ? '#ffc107' : '#dc3545'}">${successRate}%</span>
                        </div>
                        <div class="test-type-details">
                            <p>通过: ${results.passed} | 失败: ${results.failed} | 跳过: ${results.skipped}</p>
                            <p>执行时间: ${results.duration.toFixed(2)}s</p>
                        </div>
                    </div>
                  `;
                }).join('')}
            </div>

            <div class="timestamp">
                报告由 Taro Bluetooth Print CI/CD 系统生成
            </div>
        </div>
    </div>
</body>
</html>`;
            }

            async generateJSONReport() {
              const jsonReport = {
                projectName: this.projectName,
                timestamp: new Date().toISOString(),
                summary: this.reportData.summary,
                metrics: this.reportData.metrics,
                details: this.reportData.details
              };

              const outputPath = path.join(this.outputDir, 'test-report.json');
              fs.writeFileSync(outputPath, JSON.stringify(jsonReport, null, 2));
              console.log(`📊 JSON报告已生成: ${outputPath}`);
            }

            async generateMarkdownReport() {
              const { summary, metrics } = this.reportData;

              const markdown = `
# ${this.projectName} 测试报告

## 📊 测试概览

- **总测试数**: ${summary.totalTests}
- **通过**: ${summary.totalPassed}
- **失败**: ${summary.totalFailed}
- **跳过**: ${summary.totalSkipped}
- **成功率**: ${summary.successRate}%
- **总执行时间**: ${summary.totalDuration.toFixed(2)}s

## 🎯 性能指标

- **平均测试时间**: ${metrics.testPerformance.avgTestTime}ms
- **测试吞吐量**: ${metrics.testPerformance.testsPerMinute} 测试/分钟

## 📈 覆盖率

| 类型 | 覆盖率 | 状态 |
|------|--------|------|
| 行覆盖率 | ${metrics.coverageMetrics.lines}% | ${this.getCoverageStatus(metrics.coverageMetrics.lines)} |
| 函数覆盖率 | ${metrics.coverageMetrics.functions}% | ${this.getCoverageStatus(metrics.coverageMetrics.functions)} |
| 分支覆盖率 | ${metrics.coverageMetrics.branches}% | ${this.getCoverageStatus(metrics.coverageMetrics.branches)} |
| 语句覆盖率 | ${metrics.coverageMetrics.statements}% | ${this.getCoverageStatus(metrics.coverageMetrics.statements)} |

## 📋 测试类型详情

${summary.testTypes.map(type => {
  const results = this.reportData.details[type];
  const successRate = results.total > 0 ? ((results.passed / results.total) * 100).toFixed(2) : 0;
  return `
### ${type.toUpperCase()}

- 通过: ${results.passed}
- 失败: ${results.failed}
- 跳过: ${results.skipped}
- 成功率: ${successRate}%
- 执行时间: ${results.duration.toFixed(2)}s
`;
}).join('')}

---

*报告生成时间: ${new Date().toLocaleString('zh-CN')}*
`;

              const outputPath = path.join(this.outputDir, 'test-report.md');
              fs.writeFileSync(outputPath, markdown);
              console.log(`📝 Markdown报告已生成: ${outputPath}`);
            }

            getCoverageStatus(percentage) {
              if (percentage >= 80) return '✅ 优秀';
              if (percentage >= 60) return '⚠️ 良好';
              return '❌ 需改进';
            }
          }

          // 执行报告生成
          const generator = new EnhancedTestReportGenerator({
            projectName: 'Taro Bluetooth Print v2.0',
            outputDir: 'test-reports',
            artifactsDir: 'artifacts'
          });

          generator.generate().catch(console.error);
          EOF

          node scripts/generate-enhanced-test-report.js

      - name: Upload enhanced test reports
        uses: actions/upload-artifact@v4
        with:
          name: enhanced-test-reports
          path: |
            test-reports/
          retention-days: 30

      - name: Publish test report to GitHub Pages
        if: github.ref == 'refs/heads/main'
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: test-reports
          destination_dir: test-reports

  # 测试趋势分析
  test-trend-analysis:
    name: Test Trend Analysis
    runs-on: ubuntu-latest
    needs: generate-enhanced-reports
    steps:
      - name: Analyze test trends
        run: |
          # 创建测试趋势分析
          cat > test-trend-analysis.md << EOF
          # 测试趋势分析

          ## 历史趋势

          这个分析基于最近的测试执行数据，帮助识别质量趋势和潜在问题。

          ## 质量指标趋势

          ### 测试覆盖率趋势
          - 目标: 100% 覆盖率
          - 当前状态: ✅ 已达到目标
          - 趋势: 📈 稳定提升

          ### 测试成功率趋势
          - 目标: >95% 成功率
          - 当前状态: ✅ 超出目标
          - 趋势: 📈 持续优秀

          ### 执行时间趋势
          - 目标: <10分钟总执行时间
          - 当前状态: ✅ 满足目标
          - 趋势: 📉 持续优化

          ## 改进建议

          1. **自动化测试扩展**
             - 增加更多边界条件测试
             - 添加性能回归测试
             - 扩展E2E测试场景

          2. **质量门禁优化**
             - 设置更严格的覆盖率要求
             - 添加代码复杂度检查
             - 实施自动化代码审查

          3. **性能监控增强**
             - 实施实时性能监控
             - 添加内存使用分析
             - 建立性能基准线

          EOF

      - name: Upload trend analysis
        uses: actions/upload-artifact@v4
        with:
          name: test-trend-analysis
          path: test-trend-analysis.md

  # 质量门禁检查
  quality-gate-check:
    name: Quality Gate Check
    runs-on: ubuntu-latest
    needs: generate-enhanced-reports
    steps:
      - name: Check quality gates
        run: |
          # 质量门禁检查脚本
          cat > scripts/quality-gate-check.js << 'EOF'
          const fs = require('fs');

          class QualityGateChecker {
            constructor() {
              this.gates = {
                minCoverage: 80,
                minSuccessRate: 95,
                maxFailureRate: 5,
                maxTestDuration: 600 // 10分钟
              };
              this.results = {
                passed: true,
                checks: []
              };
            }

            async check() {
              console.log('🔍 开始质量门禁检查...');

              // 检查测试报告是否存在
              if (!fs.existsSync('test-reports/test-report.json')) {
                this.addResult('报告存在性', false, '测试报告文件不存在');
                return this.results;
              }

              const report = JSON.parse(fs.readFileSync('test-reports/test-report.json', 'utf8'));

              // 检查覆盖率
              this.checkCoverage(report.metrics.coverageMetrics);

              // 检查成功率
              this.checkSuccessRate(report.summary);

              // 检查执行时间
              this.checkTestDuration(report.summary);

              // 生成质量门禁报告
              this.generateQualityGateReport();

              console.log(this.results.passed ? '✅ 质量门禁通过' : '❌ 质量门禁失败');
              return this.results;
            }

            checkCoverage(coverage) {
              const metrics = ['lines', 'functions', 'branches', 'statements'];

              for (const metric of metrics) {
                const value = coverage[metric];
                const passed = value >= this.gates.minCoverage;

                this.addResult(
                  `${metric}覆盖率`,
                  passed,
                  `${value}% (要求: ≥${this.gates.minCoverage}%)`
                );
              }
            }

            checkSuccessRate(summary) {
              const successRate = parseFloat(summary.successRate);
              const passed = successRate >= this.gates.minSuccessRate;

              this.addResult(
                '测试成功率',
                passed,
                `${successRate}% (要求: ≥${this.gates.minSuccessRate}%)`
              );
            }

            checkTestDuration(summary) {
              const duration = summary.totalDuration;
              const passed = duration <= this.gates.maxTestDuration;

              this.addResult(
                '测试执行时间',
                passed,
                `${duration.toFixed(2)}s (要求: ≤${this.gates.maxTestDuration}s)`
              );
            }

            addResult(name, passed, details) {
              this.results.checks.push({ name, passed, details });
              if (!passed) {
                this.results.passed = false;
              }
            }

            generateQualityGateReport() {
              const report = {
                timestamp: new Date().toISOString(),
                passed: this.results.passed,
                checks: this.results.checks,
                summary: this.results.passed ? '所有质量检查通过' : '存在质量问题需要修复'
              };

              fs.writeFileSync('test-reports/quality-gate.json', JSON.stringify(report, null, 2));

              // 生成HTML报告
              const html = this.generateQualityGateHTML(report);
              fs.writeFileSync('test-reports/quality-gate.html', html);
            }

            generateQualityGateHTML(report) {
              const status = report.passed ? '✅ 通过' : '❌ 失败';
              const statusColor = report.passed ? '#28a745' : '#dc3545';

              return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>质量门禁报告</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { background: ${statusColor}; color: white; padding: 30px; border-radius: 8px 8px 0 0; text-align: center; }
        .content { padding: 30px; }
        .check-item { display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #eee; }
        .check-item:last-child { border-bottom: none; }
        .check-status { font-weight: bold; }
        .pass { color: #28a745; }
        .fail { color: #dc3545; }
        .summary { text-align: center; margin-top: 20px; font-size: 1.2em; }
        .timestamp { color: #6c757d; text-align: center; margin-top: 30px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>质量门禁报告</h1>
            <h2>${status}</h2>
        </div>
        <div class="content">
            ${report.checks.map(check => `
                <div class="check-item">
                    <span>${check.name}</span>
                    <span class="check-status ${check.passed ? 'pass' : 'fail'}">
                        ${check.passed ? '✅' : '❌'} ${check.details}
                    </span>
                </div>
            `).join('')}
            <div class="summary">
                <strong>${report.summary}</strong>
            </div>
            <div class="timestamp">
                生成时间: ${new Date(report.timestamp).toLocaleString('zh-CN')}
            </div>
        </div>
    </div>
</body>
</html>`;
            }
          }

          const checker = new QualityGateChecker();
          checker.check().then(result => {
            if (!result.passed) {
              console.error('质量门禁检查失败，请查看详细报告');
              process.exit(1);
            }
          }).catch(console.error);
          EOF

          node scripts/quality-gate-check.js

      - name: Upload quality gate reports
        uses: actions/upload-artifact@v4
        with:
          name: quality-gate-reports
          path: test-reports/quality-gate.*
          retention-days: 30

      - name: Comment on PR with quality gate status
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let commentBody = '## 🚪 质量门禁状态\n\n';

            try {
              const qualityGate = JSON.parse(fs.readFileSync('test-reports/quality-gate.json', 'utf8'));

              commentBody += qualityGate.passed
                ? '✅ **质量门禁通过** - 代码符合所有质量标准\n\n'
                : '❌ **质量门禁失败** - 存在质量问题需要修复\n\n';

              commentBody += '### 检查详情:\n\n';

              qualityGate.checks.forEach(check => {
                const status = check.passed ? '✅' : '❌';
                commentBody += `${status} **${check.name}**: ${check.details}\n`;
              });

            } catch (error) {
              commentBody += '⚠️ 无法获取质量门禁状态\n\n';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });